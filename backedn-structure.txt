Deisgning the backend, desiging the APIs so that any front end can talk to i, maybe a mobile front end, it can be core android, iOS, react native, flutter etc
or in the frontend it could be nextJs, react, angular, vue, etc.

So we wanna desig a robust API for that.

step1: npm init

step2: instead of common js, we change it module js, so that, you can now import from this, the from syntax
"type" : "module",  

step3: dev dependencies:
npm i --save-dev nodemon prettier

step 4: have some kinda linters or prettier, so that when merging gits it dont creat havoc 
Create: .prettierrc file
{
    "singleQuote": false,
    "bracketSpacing": true,
    "tabWidth": 2,
    "trailingComma": "es5",
    "semi": true
}

step 5: .prettierignore:
/.vscode
/node_modules
./dist

*.env
.env
.env.*

step 6: create:
src/index.js
cd src
mkdir controllers, db, middlewares, models, routes, utils
$ touch app.js index.js constants.js .env .env.sample
$ touch db/index.js
$ cd models
$ touch comment.models.js like.models.js playlist.models.js subscription.models.js tweet.models.js user.models.js video.models.js

step 7: install express
npm i express

step 8: install mongoose (is a ORM), standing bwn u and ur database, cz u dont talk to database directly theres in an ORM
 npm i mongoose

step 9: inside src in package.json in scripts, write 
"start" : "node src/index.js"
and run: npm run start (npm = package manager, start = keyword, run=command)

step 10: as it aint gonna constantly run so, 
in scripts use nodemon
"dev": "nodemon src/index.js"
npm run dev

step 11: inject your logger
Install Dependencies:

npm install winston morgan

Create the Logger Configuration File:

🐐🥀Copy and paste this code into logger.js:

JavaScript

import { createLogger, format, transports } from "winston";
const { combine, timestamp, json, colorize, printf } = format;

// Custom format for console logs with colors
const consoleLogFormat = format.combine(
    format.colorize(),
    format.printf(({ level, message }) => {
        return `${level}: ${message}`;
    })
);

// Create the Winston logger
const logger = createLogger({
    level: 'info', // Log only messages of level 'info' and above (info, warn, error)
    format: combine(
        timestamp(), // Add a timestamp to each log
        json()       // Log in JSON format
    ),
    transports: [
        // Transport 1: Log to the console
        new transports.Console({
            format: consoleLogFormat,
        }),
        // Transport 2: Log to a file
        new transports.File({ filename: 'app.log' }) // All logs will be saved in app.log
    ],
});

export default logger;

🥀Use the Logger in Your Main App File (e.g., index.js)
import express from 'express';
import morgan from 'morgan';
import logger from './logger.js'; // Import your custom logger

const app = express();
const port = 3000;

// --- Logger Integration ---

// 1. Use Morgan to automatically log all HTTP requests
// We're telling Morgan to send its logs to our Winston logger's 'info' level
app.use(morgan('tiny', {
    stream: {
        write: (message) => logger.info(message.trim()),
    },
}));

// --- Your Application Code ---

app.get('/', (req, res) => {
    // 2. Example of a custom log message
    logger.info("A request was made to the homepage.");
    res.send('Hello World!');
});

app.get('/error', (req, res) => {
    // 3. Example of a custom error log
    try {
        throw new Error("This is a sample error!");
    } catch (error) {
        logger.error(error.message);
        res.status(500).send('Something went wrong!');
    }
});


app.listen(port, () => {
    logger.info(`Server is running on port: ${port}...`);
});

***creat a .gitignore file

step 12: connect database professionally in MERN
goto app.js

step 13: insall dotenv, since the server might not have the latest node version
npm i dotenv 

if not getting port from .env, in your scripts use:
"dev": "nodemon -r dotenv/config --experimental-json src/index.js"

step 14://who should be able to talk to yer database? CORS (cross origin recourse policy/ source)

inorder to configure this install:
npm i cors

step 15: add middlewares,
middlewares are in bwn Configuration so that you can do certain things in bwn,
ex: a request come to ur server and ur server is going to respond to that request, but should ur server be responding to that request or the request shouldnt come to you, or when the req comes to you in bwn, i want to manipulare that to do some like access cookies or maybe i want to inject some objects, so all this things are known as middlewares,
and cors is one such middlewares

//middleware
app.use(
    cors({
        //objs as options, so what should and shoulnt be allowed
        origin: process.env.CORS_ORIGIN,
        credentials: true
    })
)

//WHAT IS ALLOWED TO MAKE REQUEST?
CORS_ORIGIN=* //ALLOWED TO EVERYNYAN

# CORS_ORIGIN=http://localhost:300 #add the frontend url to make it more secure

//middlewares from express to make it more secure
app.use(express.json({limit: "32kb"}))//all the json data is allowed to come in
app.use(ecpress.urlencoded({extended: true, limit: "32kb"})) //data to come in url formatted
//serving assests (images, css, etc)
app.use(express.static("public"))

step 16:
connect to database use mongoose

go to atlas
in ntwrk access:
0.0.0.0/0 (This access list entry potentially allows access to all IPv4 addresse)

in constants.js 
export const DB_NAME = "vidtube"

step 17: in DB/index.js 
connect to your database

**WHENEVER YOU ARE CONNECTING TO DATABASE, YOU HAVE TO REMEMBER THIS TWO THINGS:
1. Database connection may not always go through, theres always a chance of errors in the database,
That means always wrap ur databse connections with:
either a try-catch or promises

2. Database is always in another continent

Conclusion:
Database connection takes time, so you always want to async await your request.

import mongoose from "mongoose";
import { DB_NAME } from "../constants";

const connectDB = async () =>
{
    try{
        //connect via mongoose through url
        const connectionInstance= await mongoose.connect(`${process.env.MONGODB_URL}/${DB_NAME}`)

        console.log(`\n MongoDB connected ! DB host: ${connectionInstance.connection.host}`);
        
    }
    catch(error){
        console.log("MongoDB Connection Error", error);
        process.exit(1);
    }
}

when succesfully connected will show: 

 MongoDB connected ! DB host: ac-w4oflfj-shard-00-01.a4ijno8.mongodb.net
Server is running on port 8000

step 18:
Standarized error and response from server in MERN
Asynchrounous handler!
wrap all our requests in Asynchrounous handler throgugh higherorder js

utils/asyncHandler.js:

//job to get recive function, all those callbacks will be stored and sendint it back

//HIgher Order fn, accepting parameter as fn, aswell as returning parameter as a fn
const asyncHandler = (requestHandler) => {
    return (req, res, next) => {
        Promise.resolve(requestHandler(req,res,next)).catch((err) => next(err))
    }
}

//exportin
export {asyncHandler}

step 19: 
sending standarized response to the frontend 

utils/ApiResponse.js
class ApiResponse {
    constructor(statusCode, data, message = "Success") {
        this.statusCode = statusCode
        this.data = data
        this.message = message
        this.success = statusCode < 400
    }
}

export {ApiResponse}   

step 20:
for error response

step 21: 
Healthcheck routes and testing with postman
say when deployed on AWS or anyother cloud provider, they have thsese automated load balanceer, which are depended on this health check up, they want give em endpoint, they will do a health checup perioudically every 5-10 min etc, the job of this endpoint is give you back, hey everything is up and running,

controllers/healthcheck.controller.js

import {ApiResponse} from "..utils/ApiResponse.js" 
import {AsyncHandler} from "..utils/AsyncHandler.js"

//no need to do try-catch, jsut use: asyncHandler
const healthcheck = asyncHandler(async(req, res)=>{
    return res
      .status(200)
      //standarise it .json({message: "test ok"})
      .json(new ApiResponse(200, "OK", "Health check successfull"))
})

export {healthcheck}

step 22:
each of the model will have a controller
routes, each controller will have it own routes

step 23:
go to models according to ur eraser code,

the whole idea is, in the mongoDB, the mongoose is going to go ahead and create a document with the structure, if this doc doesnt exist, its going to go ahead and create that, and while creating its going to use the mongoose feature

ex: mongoose is saying hey mongoose i want to build a model, a new structure, a new document in my database, that document will be called as user, and the schema that is being followed , the structure that my database is going to follow i will refer to that user schema

//MONGODB allows you to have aggregation, it lets you filter the data, its kinda like complex join operation in the world of document databases,

Basically it allows you to have multiple stages of operation

step 24: npm i mongoose-aggregate-paginate

import mongooseAggregatePaginate from "mongoose-aggregate-paginate";

videoSchema.plugin(mongooseAggregatePaginate);

step 25: Mongoose hooks, and methods in mongoose
https://mongoosejs.com/docs/middleware.html

so Basically mongoose provides you with, 
prehooks and posthooks,
prehooks: just before savign the database its being sent from the code base that, go ahead and save it in the database, just before saving it you can perform some additional operation.

posthooks: just after saving the database, before it returns the response we will add some functionality 

step 26:
for password enripting use: npm i bcrypt

then encrypt and decrpy the password, the check if identical 

step 27: check if logged in

//islogged in? generate access and refresh token, jwt tokens
npm i jsonwebtoken
VIDEOTUBE/genSecrets.js

ACCESS_TOKEN_SECRET= 83a191e8c3c9d3e9d1cabd7cbe539afa0d2c05745bcfa9c39e441686388bc412990fae393d4537bd2cb10ea0890aad50c1780f33053ec44b2c3177b51c481fae
REFRESH_TOKEN_SECRET= a0374024e4563eee71a55c58d4e3caca37d06783ace4cd703c9dd6d1ccb1809e5fc73d3e6265cb0a2e30bc63a8925404639e74f3086af4d1599d257e7357f553
ACCESS_TOKEN_EXPIRY= 1d

REFRESH_TOKEN_EXPIRY= 10d

step 28: Handling files, giving superPower to express so it can do that,

Usual case: 
u just upload the images in the folder of your server, so that u can just store the URL of it.

Majority case: you will handover this images to some third party, maybe aws, maybe cloudinary
we using cloudnary in here

///Install cookie parse
npm i cookie-parser
in app.js:
import cookieParse from ""cookie-parser"

via express you can read users cookies, but to handle images we have to use 3rd party stuff and that is:
 npm i multer

//this will handle the files

middleware/multer.middleware.js

import multer from "multer";


step 29: https://cloudinary.com/documentation/node_integration
create cloudinary.js
go to cloudinary 
and:
npm i cloudinary

step 30: writing controllers: 
user registration
healthcheck.router.js (designed the functionality of the controller) --->  app.js (imported the route as a healthcheck router, serving it on /api/v1/healthcheck) 

create a new controller as every route should have its own controller, its a standard process

step 31: //We didnt use as the error solved, but this is a production level stuff
//app.use(errorHandler)

step 32: write login controller in MERN 
  //sending all data
    return res
     .status(200)
     .cookie("accessToken", accessToken, options)
     .cookie("refreshToken", refreshToken, options)
     .json(new ApiResponse(
        200,
        { user: loggedInUser, accessToken, refreshToken}, //**cause in mobile apps you cant set the cookies**!!
        "User logged in successfully"

        /**
         * This is the part where you ask your fronend team, this is how am crafting and will send the response, do you want to be manipulated, do ya want me to send the refresh token, keeping the security and everything in mind, if not fine as well
         */


step 33:
HOW TO GENERATE new refresh token;
the whole intera' of user talkin to server happens only through access token 

As soon as access token is nullified or its not valid, the server returns a very special code ex: 401,

now if the user/client recives this code, that means he has to reissue his access token!

and how that reissue access token works?
@: so once you recive the nullified code, in this case 401, you will request to the refresh token route, say: /refresh_token , this refresh token route is going to freshly generate two tokens for you,
1: refresh token, 2: access token,
now, 
    the proggramers job is to: as soon the new refresh token generates, delete the existing refresh token, and replace it with the freshly generated one, and the copy will be sent to user 
summary: That access token is meant to live short term, and in case you want to renew that, you can do that by sending or sending a request to a special route along with the refresh token cz its living in the databse, so i can validate for you, and can issue you a new token, in case i dont wanna issue this, i want to log you out, then i can delete this refresh token from the database, and hence ill never be able to match your refresh token, then thats it you are logged out for 15 mins


step 34:
   //TO DO: need to come back here after middleware, by middleware will be able to tell whos the user
    //easy way: we can look into users cookie, just decode it and extract the user id from it

//Before hitting the controller, we can run some piece of code, and this code on behalf of us is going to evry single time, take the access token, and once have this access token, we are gonna decode that, and we gonna injet some piece of code into it, the code: {
    req ={
        id = _id
    }
}, then we will forward it to the controller

User (access) --> middleware(req{ id=_id}) --> controller (_id)

dry principle: dont repeat yourself

step 35: inject middleware in the routes

step 36: CRUD operation:
                         wanna provide more functionality to the user route, probably how to update the password, email username etc,
                         use diff routes
                         how to find the current active user/logged in user, update avatar cover image etc


step 37: aggregation Pipeline:
                              gives so much more, not only findById, ex like join operation this doc that doc filter combien em up 

/*
*Aggregation Pipeline: 
are basically pipelines(stages):
each stage you put filtering, then next step will only process that

syntax: 
db.orders.aggregate{
    //each stage consists of array:
    [
        {
            $match hwegfweyfwyefhywe9
        }
    ]
}
*/

data -> 1.fileter step -> 2nd filetr->  and so on


//
What is a Healthcheck?​
A healthcheck endpoint is a simple API route that monitoring services ping to verify your server is alive and running​

Why You Need It​
Uptime Monitoring: Services like AWS, Docker, Kubernetes check this endpoint regularly​

Load Balancers: Removes unhealthy servers from rotation automatically​

Alerting: Get notified immediately if your API goes down​

No Authentication Needed: Should be publicly accessible so monitoring tools can access it​

How It Works​
Basic Response​
Returns 200 OK status with minimal information:​